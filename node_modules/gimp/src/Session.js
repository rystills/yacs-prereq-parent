var spawn = require('child_process').spawn;

module.exports = class {

	constructor(binSrc) {
		this._binSrc = binSrc;
		this._childProcess = null; // Promise
		this._lastCmd = Promise.resolve();
	}

	open() {
		return this._getChildProcess().then(() => {
			return this;
		});
	}

	_getChildProcess() {
		if (!this._childProcess) {
			this._childProcess = this._createChildProcess().then(function (childProcess) {
				return new Promise((resolve, reject) => {
					var onLoad = (data) => {
						if (data.toString().trim().substr(0, 3) === 'ts>' || data.toString().trim().substr(0, 1) === '>') {
							childProcess.stdout.removeListener('data', onLoad);
							resolve(childProcess);
						}
					};

					childProcess.stdout.on('data', onLoad);
				});
			});
		}

		return this._childProcess;
	}

	_createChildProcess() {
		return new Promise((resolve, reject) => {
			
			try {
				var childProcess = spawn(this._binSrc, ['-i', '-b', '-']);
			} catch (e) {
				return reject(new Error('Failed opening ' + e.message));
			}

			childProcess.once('error', (err) => {
				if (err.message.indexOf('spawn') !== -1) {
					this._childProcess = Promise.reject(new Error('Failed opening session ' + err.message));
					childProcess.removeAllListeners();
				}
			}); // no spawn, no kill, no message

			var lastStdErr = '';

			childProcess.stderr.on('data', function (data) {
				lastStdErr = data.toString();
			});

			childProcess.once('exit', (code) => {
				childProcess.removeAllListeners();
				if (code) {
					this._childProcess = Promise.reject(new Error('Session closed with error ('+code+') : ' + lastStdErr));
					return;
				}
				this._childProcess = Promise.reject(new Error('Session closed'));
			}); // bye bye

			resolve(childProcess);

		});
	}

	close() {
		if (!this._childProcess) {
			this._childProcess = Promise.reject(new Error('Session closed by user'));
			return Promise.resolve(this);
		}

		return this._childProcess
			.catch(() => { return this; })
			.then((childProcess) => {
				return new Promise((resolve, reject) => {
					process.once('exit', () => {
						this._childProcess = Promise.reject(new Error('Session closed by user'));
						resolve(this);
					});
					childProcess.kill();
				});
			});
	}

	_exec(cmd) {
		return this._getChildProcess().then((childProcess) => {

			return new Promise((resolve, reject) => {

				var out = '';

				var analyze = (data) => {

					out += data.toString();

					var lines = out.split(/\n|\r/);

					// Use STDERR ?
					// Response #xxx == expression returns
					// Resonse Error: xx == error
					if (lines.find(function (line) { return line.substr(0, 5) === 'Error' })) {
						this._task = null;
						childProcess.stdout.removeListener('data', analyze);
						return reject(new Error(lines[0]));
					}

					if (lines.find(function (line) { return line.substr(0, 3) === 'ts>'; })) {
						this._task = null;
						childProcess.stdout.removeListener('data', analyze);
						resolve(lines[0]);
					}
				};

				childProcess.stdout.on('data', analyze);
				childProcess.stdin.write(cmd + '\n');
			});
		});
	}

	exec(cmd) {

		var flow = () => {
			return this._exec(cmd);
		};

		this._lastCmd = this._lastCmd.then(flow, flow);

		return this._lastCmd;
	}

};